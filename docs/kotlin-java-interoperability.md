# Kotlin Annotations for Java Interoperability

This document lists the most useful Kotlin annotations for ensuring smooth interoperability with Java, along with usage examples.

---

## ðŸ§© Annotation Table

| Annotation              | Description / Purpose                                                                                                   |
|-------------------------|-------------------------------------------------------------------------------------------------------------------------|
| `@JvmName`              | Changes the name of a method or property in the generated bytecode for Java usage.                                      |
| `@file:JvmName`         | Changes the name of the generated class for top-level functions in a Kotlin file.                                       |
| `@JvmOverloads`         | Generates overloads for functions with default parameter values, making them usable from Java.                          |
| `@JvmStatic`            | Marks a method or property as static when used in an `object` or `companion object`.                                    |
| `@JvmField`             | Exposes a field directly (without getter/setter), useful for constants or public fields.                                |
| `@Throws`               | Declares the exceptions a function might throw, making them visible in Java.                                            |
| `@JvmSuppressWildcards` | Suppresses wildcard generation for generic types to improve Java signature clarity.                                     |
| `@JvmWildcard`          | Forces a wildcard (`?`) to appear in the generic type for Java compatibility.                                           |
| `@JvmDefault`           | (Deprecated in favor of JVM 8 default methods) Allows default implementations in interfaces.                            |
| `@Throws`               | Help Java Code to manage exceptions                                                                                     |
| `@JvmSynthetic`         | Synthetic targets become inaccessible for Java sources at compile time while still being accessible for Kotlin sources. |

---

## ðŸ§ª Examples

### `@JvmName`

```kotlin
@JvmName("multiplyInts")
fun multiply(a: Int, b: Int): Int = a * b
```

**In Java:**

```java
int result = MyKt.multiplyInts(2, 3);
```

---

### `@file:JvmName`

```kotlin
// File: utils.kt
@file:JvmName("StringUtils")
fun trimAndLower(input: String): String = input.trim().lowercase()
```

**In Java:**

```java
String result = StringUtils.trimAndLower(" Text ");
```

---

### `@JvmOverloads`

```kotlin
class Greeter {
    @JvmOverloads
    fun greet(name: String = "World", punctuation: String = "!") {
        println("Hello, $name$punctuation")
    }
}
```

**In Java:**

```java
Greeter g = new Greeter();
g.greet();                    // Hello, World!
g.greet("Alice");             // Hello, Alice!
g.greet("Alice", "?");        // Hello, Alice?
```

---

### `@JvmStatic`

```kotlin
class MathUtils {
    companion object {
        @JvmStatic
        fun square(x: Int): Int = x * x
    }
}
```

**In Java:**

```java
int s = MathUtils.square(5);  // Static call
```

---

### `@JvmField`

```kotlin
object Constants {
    @JvmField
    val PI = 3.1415
}
```

**In Java:**

```java
double pi = Constants.PI;
```

---

### `@Throws`

```kotlin
@Throws(IOException::class)
fun readFile(path: String): String {
    // ...
    throw IOException("File not found")
}
```

**In Java:**

```java
try {
    String content = MyKt.readFile("file.txt");
} catch (IOException e) {
    e.printStackTrace();
}
```

---

### `@JvmSuppressWildcards`

```kotlin
fun <T> useList(@JvmSuppressWildcards list: List<T>) {
// Java sees List<T> instead of List<? extends T>
}
```

---

### `@JvmWildcard`

```kotlin
fun getList(): List<@JvmWildcard String> {
    return listOf("A", "B")
}
```

**In Java:**  
Seen as `List<? extends String>`

---

### `@JvmDefault` (deprecated)

```kotlin
interface Logger {
    @JvmDefault
    fun log(message: String) {
        println("LOG: $message")
    }
}
```

---
> **Note:** Prefer using default interface methods with `-Xjvm-default=all` compiler option instead of this annotation in recent Kotlin versions.


### @JvmSynthetic
```kotlin
class AuthManager {
    @JvmSynthetic
    fun generateToken(userId: String): String {
    return "token_for_$userId"
    }
}
```

In Java:
The method generateToken is not accessible from Java code.

In Kotlin:

```kotlin
val token = AuthManager().generateToken("user123")
```

> **Note:** `@JvmSynthetic` is useful to hide internal APIs from Java consumers while keeping them accessible in Kotlin. When combined with the `internal` modifier, the API is hidden from Java, but remains accessible within the same module in Kotlin.

---

## âœ… Notes

- Always test your Kotlin library with Java consumers.
- Keep public APIs simple and Java-friendly.
- Avoid advanced Kotlin-only features (e.g., inline classes, reified types) unless strictly necessary.
